<!DOCTYPE html>
<html>
<head>
    <title>üèîÔ∏è WILDERNESS SURVIVAL - 3D Open World</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial Black', sans-serif;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border-left: 5px solid #ff6b6b;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border-right: 5px solid #4ecdc4;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #inventory {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 60px;
            border: 2px solid #ff6b6b;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 40px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            position: relative;
        }
        
        .slot.selected::after {
            content: '‚ñº';
            position: absolute;
            top: -25px;
            color: cyan;
            font-size: 20px;
            text-shadow: 0 0 10px cyan;
        }
        
        .slot .key {
            font-size: 14px;
            color: #888;
        }
        
        .slot .item {
            font-size: 28px;
            font-weight: bold;
        }
        
        .slot .count {
            font-size: 12px;
            color: #4ecdc4;
        }
        
        #time-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px 30px;
            border-radius: 30px;
            border: 1px solid cyan;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
            font-size: 18px;
            letter-spacing: 2px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 0 20px cyan;
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: cyan;
            border-radius: 50%;
            box-shadow: 0 0 10px cyan;
        }
        
        #message {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            text-shadow: 0 0 20px cyan, 0 0 40px blue;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px 40px;
            border-radius: 50px;
            border-left: 5px solid cyan;
            border-right: 5px solid magenta;
            transition: all 0.3s;
            opacity: 0;
            font-weight: bold;
            letter-spacing: 2px;
            white-space: nowrap;
        }
        
        #message.show {
            opacity: 1;
            bottom: 180px;
        }
        
        #compass {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-family: monospace;
            letter-spacing: 5px;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }
        
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0);
            pointer-events: none;
            z-index: 1000;
            transition: background 0.1s;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div>‚ù§Ô∏è HEALTH: <span id="health">100</span>%</div>
        <div>‚ö° ENERGY: <span id="energy">100</span>%</div>
        <div>üçó FOOD: <span id="food">80</span>%</div>
        <div>üíß WATER: <span id="water">70</span>%</div>
        <div style="margin-top:10px; color:#888;">üìç POS: <span id="pos">0,0</span></div>
    </div>
    
    <div id="stats">
        <div>üèπ KILLS: <span id="kills">0</span></div>
        <div>üå≤ WOOD: <span id="wood">10</span></div>
        <div>ü™® STONE: <span id="stone">5</span></div>
        <div>üî• XP: <span id="xp">0</span>/100</div>
        <div>‚öîÔ∏è DAMAGE: <span id="damage">15</span></div>
    </div>
    
    <div id="time-display">
        üåû DAY
    </div>
    
    <div id="compass">
        N  ‚Ä¢  NE  ‚Ä¢  E  ‚Ä¢  SE  ‚Ä¢  S  ‚Ä¢  SW  ‚Ä¢  W  ‚Ä¢  NW  ‚Ä¢  N
    </div>
    
    <div id="inventory">
        <div class="slot selected" id="slot1">
            <span class="key">1</span>
            <span class="item">ü™ì</span>
            <span class="count" id="count1">‚àû</span>
        </div>
        <div class="slot" id="slot2">
            <span class="key">2</span>
            <span class="item">üî™</span>
            <span class="count" id="count2">‚àû</span>
        </div>
        <div class="slot" id="slot3">
            <span class="key">3</span>
            <span class="item">üèπ</span>
            <span class="count" id="count3">12</span>
        </div>
        <div class="slot" id="slot4">
            <span class="key">4</span>
            <span class="item">üî•</span>
            <span class="count" id="count4">3</span>
        </div>
        <div class="slot" id="slot5">
            <span class="key">5</span>
            <span class="item">üèïÔ∏è</span>
            <span class="count" id="count5">1</span>
        </div>
    </div>
    
    <div id="crosshair"></div>
    <div id="message">üèπ WELCOME TO THE WILDERNESS</div>
    <div id="damage-overlay"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        
        // =============================================
        // ADVANCED SETUP
        // =============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 150);
        
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 8, 20);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.bias = 0.0001;
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // =============================================
        // ADVANCED LIGHTING SYSTEM
        // =============================================
        // Sun light
        const sunLight = new THREE.DirectionalLight(0xfff5d1, 1.8);
        sunLight.position.set(50, 80, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        sunLight.shadow.bias = -0.0005;
        scene.add(sunLight);
        
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);
        
        // Player light (torch effect)
        const playerLight = new THREE.PointLight(0xffaa66, 1, 20);
        playerLight.castShadow = true;
        playerLight.shadow.mapSize.width = 1024;
        playerLight.shadow.mapSize.height = 1024;
        scene.add(playerLight);
        
        // =============================================
        // CREATE PLAYER CHARACTER (FULL 3D MODEL)
        // =============================================
        const player = new THREE.Group();
        
        // Body
        const bodyGeo = new THREE.CylinderGeometry(0.8, 0.8, 2);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3366cc, emissive: 0x112233 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1;
        body.castShadow = true;
        body.receiveShadow = true;
        player.add(body);
        
        // Head
        const headGeo = new THREE.SphereGeometry(0.6);
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 2.4;
        head.castShadow = true;
        head.receiveShadow = true;
        player.add(head);
        
        // Arms
        const armGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.2);
        const armMat = new THREE.MeshStandardMaterial({ color: 0x3366cc });
        
        const leftArm = new THREE.Mesh(armGeo, armMat);
        leftArm.position.set(-1, 1.8, 0);
        leftArm.rotation.z = 0.2;
        leftArm.castShadow = true;
        player.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeo, armMat);
        rightArm.position.set(1, 1.8, 0);
        rightArm.rotation.z = -0.2;
        rightArm.castShadow = true;
        player.add(rightArm);
        
        // Legs
        const legGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2);
        const legMat = new THREE.MeshStandardMaterial({ color: 0x224488 });
        
        const leftLeg = new THREE.Mesh(legGeo, legMat);
        leftLeg.position.set(-0.4, 0.2, 0);
        leftLeg.castShadow = true;
        player.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(legGeo, legMat);
        rightLeg.position.set(0.4, 0.2, 0);
        rightLeg.castShadow = true;
        player.add(rightLeg);
        
        // Equipment (axe on back)
        const axeHandleGeo = new THREE.CylinderGeometry(0.1, 0.1, 1);
        const axeHandleMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const axeHandle = new THREE.Mesh(axeHandleGeo, axeHandleMat);
        axeHandle.position.set(0, 1.5, -0.5);
        axeHandle.rotation.x = 0.3;
        player.add(axeHandle);
        
        const axeHeadGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        const axeHeadMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const axeHead = new THREE.Mesh(axeHeadGeo, axeHeadMat);
        axeHead.position.set(0, 1.5, -1);
        player.add(axeHead);
        
        player.position.set(0, 1, 0);
        scene.add(player);
        
        // =============================================
        // TERRAIN GENERATION (ADVANCED)
        // =============================================
        const terrainSize = 200;
        const terrainSegments = 256;
        
        const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
        terrainGeometry.rotateX(-Math.PI / 2);
        
        const positionAttribute = terrainGeometry.attributes.position;
        const colors = [];
        
        for (let i = 0; i < positionAttribute.count; i++) {
            const x = positionAttribute.getX(i);
            const z = positionAttribute.getZ(i);
            
            // Advanced terrain generation with multiple frequencies
            const y1 = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3;
            const y2 = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 2;
            const y3 = Math.sin(x * 0.8) * Math.cos(z * 0.8) * 1;
            const y4 = Math.sin(x * 2.0) * Math.cos(z * 2.0) * 0.5;
            const y5 = Math.random() * 0.3;
            
            let y = y1 + y2 + y3 + y4 + y5;
            
            // Create mountains in distance
            const distFromCenter = Math.sqrt(x*x + z*z);
            if (distFromCenter > 80) {
                y += Math.sin(distFromCenter * 0.2) * 2;
            }
            
            positionAttribute.setY(i, y);
            
            // Color based on height
            let color;
            if (y < 0) color = new THREE.Color(0x2a6f8f); // Water
            else if (y < 2) color = new THREE.Color(0x5a8c5a); // Grass
            else if (y < 4) color = new THREE.Color(0x7a6a4a); // Dirt
            else color = new THREE.Color(0x8a8a8a); // Rock
            
            colors.push(color.r, color.g, color.b);
        }
        
        terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        terrainGeometry.computeVertexNormals();
        
        const terrainMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true,
            roughness: 0.8,
            metalness: 0.1,
            flatShading: false
        });
        
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.receiveShadow = true;
        terrain.castShadow = false;
        terrain.position.y = -3;
        scene.add(terrain);
        
        // Add water with animation
        const waterGeometry = new THREE.PlaneGeometry(terrainSize + 40, terrainSize + 40, 32, 32);
        waterGeometry.rotateX(-Math.PI / 2);
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a6f8f,
            transparent: true,
            opacity: 0.6,
            emissive: 0x0a1f2f,
            roughness: 0.1,
            metalness: 0.3
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.receiveShadow = false;
        water.position.y = -2.8;
        scene.add(water);
        
        // =============================================
        // ADVANCED TREE GENERATION
        // =============================================
        const trees = [];
        
        function createAdvancedTree(x, z) {
            const group = new THREE.Group();
            
            // Sample terrain height
            let y = -3;
            const sampleX = x;
            const sampleZ = z;
            y += Math.sin(sampleX * 0.1) * Math.cos(sampleZ * 0.1) * 3;
            y += Math.sin(sampleX * 0.3) * Math.cos(sampleZ * 0.3) * 2;
            y += Math.sin(sampleX * 0.8) * Math.cos(sampleZ * 0.8) * 1;
            
            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.6, 0.8, 3);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            group.add(trunk);
            
            // Leaves (multiple layers)
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2a5a2a, emissive: 0x0a2a0a });
            
            const leaf1 = new THREE.Mesh(new THREE.ConeGeometry(1.5, 2, 8), leafMat);
            leaf1.position.y = 3;
            leaf1.castShadow = true;
            group.add(leaf1);
            
            const leaf2 = new THREE.Mesh(new THREE.ConeGeometry(1.2, 1.5, 8), leafMat);
            leaf2.position.y = 4.2;
            leaf2.castShadow = true;
            group.add(leaf2);
            
            const leaf3 = new THREE.Mesh(new THREE.ConeGeometry(0.9, 1.2, 8), leafMat);
            leaf3.position.y = 5.2;
            leaf3.castShadow = true;
            group.add(leaf3);
            
            group.position.set(x, y + 1.5, z);
            
            return group;
        }
        
        // Generate dense forest
        for (let i = 0; i < 500; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 70;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const tree = createAdvancedTree(x, z);
            scene.add(tree);
            trees.push(tree);
        }
        
        // =============================================
        // ROCKS WITH VARIATION
        // =============================================
        const rocks = [];
        
        for (let i = 0; i < 200; i++) {
            const group = new THREE.Group();
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 60;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            let y = -3;
            y += Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3;
            y += Math.sin(x * 0.3) * Math.cos(z * 0.3) * 2;
            
            const rockGeo = new THREE.DodecahedronGeometry(0.4 + Math.random() * 0.6);
            const rockMat = new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                roughness: 0.9,
                emissive: 0x111111
            });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.y = 0.3;
            rock.castShadow = true;
            rock.receiveShadow = true;
            rock.scale.set(1, 0.5 + Math.random(), 1);
            group.add(rock);
            
            group.position.set(x, y + 0.3, z);
            scene.add(group);
            rocks.push(group);
        }
        
        // =============================================
        // ADVANCED ANIMALS WITH MOVEMENT
        // =============================================
        const animals = [];
        
        class Animal {
            constructor(type, x, z) {
                this.group = new THREE.Group();
                this.type = type;
                this.speed = type === 'deer' ? 0.03 : 0.05;
                this.direction = Math.random() * Math.PI * 2;
                this.targetPos = { x, z };
                
                let y = -3;
                y += Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3;
                y += Math.sin(x * 0.3) * Math.cos(z * 0.3) * 2;
                
                let color, size;
                if (type === 'deer') {
                    color = 0xcc8866;
                    size = 0.7;
                } else {
                    color = 0x886666;
                    size = 0.5;
                }
                
                // Body
                const bodyGeo = new THREE.BoxGeometry(size, size/2, size*1.5);
                const bodyMat = new THREE.MeshStandardMaterial({ color });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = size/2;
                body.castShadow = true;
                body.receiveShadow = true;
                this.group.add(body);
                
                // Head
                const headGeo = new THREE.SphereGeometry(size/2);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.y = size;
                head.position.z = size*0.8;
                head.castShadow = true;
                this.group.add(head);
                
                // Legs
                const legGeo = new THREE.BoxGeometry(size/4, size, size/4);
                const legMat = new THREE.MeshStandardMaterial({ color });
                
                for (let i = 0; i < 4; i++) {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set(
                        (i % 2 === 0 ? -size/3 : size/3),
                        size/4,
                        (i < 2 ? -size/3 : size/3)
                    );
                    leg.castShadow = true;
                    this.group.add(leg);
                }
                
                this.group.position.set(x, y + size/2, z);
                scene.add(this.group);
            }
            
            update() {
                // Random movement
                if (Math.random() < 0.01) {
                    this.direction += (Math.random() - 0.5) * 0.5;
                }
                
                const moveX = Math.cos(this.direction) * this.speed;
                const moveZ = Math.sin(this.direction) * this.speed;
                
                this.group.position.x += moveX;
                this.group.position.z += moveZ;
                
                // Face movement direction
                this.group.rotation.y = this.direction;
                
                // Bobbing animation
                this.group.position.y += Math.sin(Date.now() * 0.005) * 0.01;
                
                // Constrain to world
                if (Math.abs(this.group.position.x) > 90) this.direction += Math.PI;
                if (Math.abs(this.group.position.z) > 90) this.direction += Math.PI;
            }
        }
        
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 60;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const type = Math.random() > 0.6 ? 'wolf' : 'deer';
            animals.push(new Animal(type, x, z));
        }
        
        // =============================================
        // CAMP WITH INTERACTIVE FIRE
        // =============================================
        const campGroup = new THREE.Group();
        
        // Tent
        const tentGeo = new THREE.ConeGeometry(3, 2, 4);
        const tentMat = new THREE.MeshStandardMaterial({ color: 0xaa6644 });
        const tent = new THREE.Mesh(tentGeo, tentMat);
        tent.position.y = 1;
        tent.castShadow = true;
        campGroup.add(tent);
        
        // Fire pit
        const fireRingGeo = new THREE.TorusGeometry(1.2, 0.15, 16, 32);
        const fireRingMat = new THREE.MeshStandardMaterial({ color: 0x886644 });
        const fireRing = new THREE.Mesh(fireRingGeo, fireRingMat);
        fireRing.rotation.x = Math.PI / 2;
        fireRing.position.y = 0.1;
        fireRing.position.z = -2;
        campGroup.add(fireRing);
        
        // Fire wood
        for (let i = 0; i < 5; i++) {
            const woodGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8);
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const wood = new THREE.Mesh(woodGeo, woodMat);
            wood.position.y = 0.4;
            wood.position.z = -2;
            wood.position.x = (i - 2) * 0.4;
            wood.rotation.z = Math.PI / 6;
            wood.rotation.x = Math.PI / 4;
            campGroup.add(wood);
        }
        
        // Fire particles
        const fireParticles = [];
        for (let i = 0; i < 20; i++) {
            const particleGeo = new THREE.SphereGeometry(0.1 + Math.random() * 0.1);
            const particleMat = new THREE.MeshStandardMaterial({ 
                color: 0xff6600, 
                emissive: 0x442200 
            });
            const particle = new THREE.Mesh(particleGeo, particleMat);
            particle.userData = {
                speed: 0.02 + Math.random() * 0.03,
                offset: Math.random() * Math.PI * 2
            };
            particle.position.y = 0.5;
            particle.position.z = -2;
            particle.position.x = (i - 10) * 0.1;
            campGroup.add(particle);
            fireParticles.push(particle);
        }
        
        campGroup.position.set(0, 0, 0);
        scene.add(campGroup);
        
        // =============================================
        // GAME STATE
        // =============================================
        const gameState = {
            health: 100,
            energy: 100,
            food: 80,
            water: 70,
            kills: 0,
            wood: 10,
            stone: 5,
            arrows: 12,
            fireStarter: 3,
            xp: 0,
            level: 1,
            time: 6,
            selectedItem: 1,
            damage: 15,
            message: ''
        };
        
        // =============================================
        // PLAYER CONTROLS
        // =============================================
        const keys = {};
        const mouseSensitivity = 0.002;
        let pitch = 0;
        let yaw = 0;
        
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement) {
                yaw -= e.movementX * mouseSensitivity;
                pitch -= e.movementY * mouseSensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                
                camera.rotation.order = 'YXZ';
                camera.rotation.y = yaw;
                camera.rotation.x = pitch;
            }
        });
        
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });
        
        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case '1': case '2': case '3': case '4': case '5':
                    gameState.selectedItem = parseInt(e.key);
                    document.querySelectorAll('.slot').forEach((slot, i) => {
                        if (i === gameState.selectedItem - 1) {
                            slot.classList.add('selected');
                        } else {
                            slot.classList.remove('selected');
                        }
                    });
                    showMessage(`SELECTED: ${getItemName(gameState.selectedItem)}`);
                    break;
                    
                case 'e':
                    showMessage('üîç SEARCHING...');
                    gameState.wood += 2;
                    break;
                    
                case 'f':
                    if (gameState.fireStarter > 0) {
                        gameState.fireStarter--;
                        showMessage('üî• FIRE STARTED');
                    } else {
                        showMessage('‚ùå NO FIRE STARTER');
                    }
                    break;
                    
                case 'r':
                    showMessage('‚ö° RESTING...');
                    gameState.energy = Math.min(100, gameState.energy + 20);
                    break;
            }
        });
        
        function getItemName(slot) {
            const items = ['AXE', 'KNIFE', 'BOW', 'FIRE', 'TENT'];
            return items[slot - 1];
        }
        
        // =============================================
        // UI FUNCTIONS
        // =============================================
        function showMessage(text) {
            const msgEl = document.getElementById('message');
            msgEl.textContent = text;
            msgEl.classList.add('show');
            setTimeout(() => msgEl.classList.remove('show'), 2000);
        }
        
        function updateHUD() {
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('energy').textContent = gameState.energy;
            document.getElementById('food').textContent = gameState.food;
            document.getElementById('water').textContent = gameState.water;
            document.getElementById('kills').textContent = gameState.kills;
            document.getElementById('wood').textContent = gameState.wood;
            document.getElementById('stone').textContent = gameState.stone;
            document.getElementById('xp').textContent = gameState.xp;
            document.getElementById('damage').textContent = gameState.damage;
            document.getElementById('pos').textContent = `${Math.round(player.position.x)},${Math.round(player.position.z)}`;
            document.getElementById('count3').textContent = gameState.arrows;
            document.getElementById('count4').textContent = gameState.fireStarter;
        }
        
        // =============================================
        // DAY/NIGHT CYCLE
        // =============================================
        function updateTime() {
            gameState.time += 0.001;
            if (gameState.time > 24) gameState.time = 0;
            
            const sunAngle = (gameState.time / 24) * Math.PI * 2;
            const sunHeight = Math.sin(sunAngle);
            
            sunLight.position.x = Math.cos(sunAngle) * 150;
            sunLight.position.y = Math.max(10, sunHeight * 150);
            sunLight.position.z = Math.sin(sunAngle) * 150;
            
            const ambientIntensity = Math.max(0.1, Math.min(0.5, sunHeight * 0.4 + 0.2));
            ambientLight.intensity = ambientIntensity;
            
            // Update player light intensity
            playerLight.intensity = 1 - Math.max(0, sunHeight * 0.8);
            
            if (sunHeight > 0.3) {
                scene.background.setHex(0x87CEEB);
                document.getElementById('time-display').innerHTML = '‚òÄÔ∏è DAY';
            } else if (sunHeight > -0.3) {
                scene.background.setHex(0x334466);
                document.getElementById('time-display').innerHTML = 'üåÖ DUSK';
            } else {
                scene.background.setHex(0x111122);
                document.getElementById('time-display').innerHTML = 'üåô NIGHT';
            }
        }
        
        // =============================================
        // FIRE ANIMATION
        // =============================================
        function animateFire() {
            fireParticles.forEach(particle => {
                particle.position.y += particle.userData.speed;
                particle.position.x += Math.sin(Date.now() * 0.005 + particle.userData.offset) * 0.01;
                
                if (particle.position.y > 1.5) {
                    particle.position.y = 0.5;
                }
            });
        }
        
        // =============================================
        // PLAYER MOVEMENT
        // =============================================
        function updatePlayer() {
            const speed = 0.15;
            const moveDirection = new THREE.Vector3();
            
            if (keys['w']) moveDirection.z -= speed;
            if (keys['s']) moveDirection.z += speed;
            if (keys['a']) moveDirection.x -= speed;
            if (keys['d']) moveDirection.x += speed;
            
            // Rotate movement direction based on camera yaw
            moveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            
            player.position.x += moveDirection.x;
            player.position.z += moveDirection.z;
            
            // Update camera position to follow player
            camera.position.x = player.position.x;
            camera.position.z = player.position.z;
            camera.position.y = player.position.y + 2.5;
            
            // Update player light
            playerLight.position.copy(player.position);
            playerLight.position.y += 2;
            
            // Update compass
            const dir = Math.round((yaw + Math.PI*2) % (Math.PI*2) * 180/Math.PI / 45);
            const dirs = ['N','NE','E','SE','S','SW','W','NW','N'];
            document.getElementById('compass').innerHTML = `‚¨ÜÔ∏è ${dirs[dir]} ‚¨áÔ∏è`;
            
            // Drain stats
            if (moveDirection.length() > 0) {
                gameState.energy -= 0.02;
                gameState.food -= 0.01;
                gameState.water -= 0.015;
            }
            
            // Regenerate health
            if (gameState.food > 50 && gameState.water > 50) {
                gameState.health = Math.min(100, gameState.health + 0.05);
            }
            
            // Check for death
            if (gameState.health <= 0 || gameState.energy <= 0 || gameState.food <= 0 || gameState.water <= 0) {
                showMessage('üíÄ YOU DIED - GAME OVER');
                gameState.health = 0;
            }
        }
        
        // =============================================
        // COLLISION DETECTION & COMBAT
        // =============================================
        function checkCollisions() {
            animals.forEach(animal => {
                const dist = player.position.distanceTo(animal.group.position);
                
                if (dist < 3 && gameState.selectedItem === 1) { // Axe range
                    if (Math.random() < 0.01) {
                        scene.remove(animal.group);
                        animals.splice(animals.indexOf(animal), 1);
                        gameState.kills++;
                        gameState.xp += 10;
                        gameState.wood += 5;
                        
                        if (gameState.xp >= 100) {
                            gameState.level++;
                            gameState.xp = 0;
                            gameState.damage += 5;
                            showMessage(`‚¨ÜÔ∏è LEVEL UP! DAMAGE +5`);
                        }
                        
                        // Damage overlay
                        document.getElementById('damage-overlay').style.background = 'rgba(255,0,0,0.3)';
                        setTimeout(() => {
                            document.getElementById('damage-overlay').style.background = 'rgba(255,0,0,0)';
                        }, 100);
                    }
                }
                
                // Animal attack
                if (animal.type === 'wolf' && dist < 2) {
                    gameState.health -= 0.5;
                }
            });
        }
        
        // =============================================
        // ANIMATION LOOP
        // =============================================
        function animate() {
            requestAnimationFrame(animate);
            
            updateTime();
            animateFire();
            updatePlayer();
            checkCollisions();
            updateHUD();
            
            // Animate trees
            trees.forEach(tree => {
                tree.rotation.z = Math.sin(Date.now() * 0.001 + tree.position.x) * 0.01;
            });
            
            // Animate animals
            animals.forEach(animal => animal.update());
            
            // Animate water
            water.position.y = -2.8 + Math.sin(Date.now() * 0.001) * 0.05;
            
            // Animate player
            if (keys['w'] || keys['s'] || keys['a'] || keys['d']) {
                player.children[2].rotation.x += 0.1; // Arms
                player.children[3].rotation.x -= 0.1;
                player.children[4].rotation.x -= 0.1; // Legs
                player.children[5].rotation.x += 0.1;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        console.log('%cüèπ WILDERNESS SURVIVAL - ULTIMATE EDITION üèπ', 'color: #4ecdc4; font-size: 24px; font-weight: bold');
        console.log('üéÆ CONTROLS:');
        console.log('   WASD - Move');
        console.log('   MOUSE - Look around');
        console.log('   1-5 - Select items');
        console.log('   E - Search for resources');
        console.log('   F - Start fire');
        console.log('   R - Rest');
        console.log('   CLICK - Lock mouse');
    </script>
</body>
</html>
